// =============================================================================
// MindLog API — Patient invite routes
// POST   /api/v1/invites                  clinician — create invite + send email
// GET    /api/v1/invites                  clinician — list own invites
// GET    /api/v1/invites/validate/:token  PUBLIC    — validate token for pre-fill
// POST   /api/v1/invites/:id/resend       clinician — resend email (max 3)
// DELETE /api/v1/invites/:id              clinician — cancel pending invite
// =============================================================================

import type { FastifyInstance } from 'fastify';
import { z } from 'zod';
import { sql } from '@mindlog/db';
import { CreateInviteSchema, UuidSchema } from '@mindlog/shared';
import { sendInviteEmail } from '../../services/messaging.js';
import { auditLog } from '../../middleware/audit.js';

const MAX_RESENDS = 3;

export default async function inviteRoutes(fastify: FastifyInstance): Promise<void> {
  const clinicianOnly = { preHandler: [fastify.requireRole(['clinician', 'admin'])] };

  // ---------------------------------------------------------------------------
  // POST /invites — create invite + send email
  // ---------------------------------------------------------------------------
  fastify.post('/', clinicianOnly, async (request, reply) => {
    const body = CreateInviteSchema.parse(request.body);
    const clinicianId = request.user.sub;
    const orgId = request.user.org_id;

    // Fetch clinician name and org name for the email
    const [clinicianRow] = await sql<{ first_name: string; last_name: string; org_name: string }[]>`
      SELECT c.first_name, c.last_name, o.name AS org_name
      FROM clinicians c
      JOIN organisations o ON o.id = c.organisation_id
      WHERE c.id = ${clinicianId}::UUID
      LIMIT 1
    `;
    if (!clinicianRow) {
      return reply.status(404).send({
        success: false,
        error: { code: 'NOT_FOUND', message: 'Clinician not found' },
      });
    }

    // Guard: email already registered as an active patient in this org
    const [existingPatient] = await sql<{ id: string }[]>`
      SELECT id FROM patients
      WHERE lower(email) = lower(${body.email})
        AND is_active = TRUE
        AND organisation_id = ${orgId}::UUID
      LIMIT 1
    `;
    if (existingPatient) {
      return reply.status(409).send({
        success: false,
        error: { code: 'PATIENT_EXISTS', message: 'A patient with this email already exists in your organisation' },
      });
    }

    // Guard: pending invite already exists (enforced by unique partial index too)
    const [existingInvite] = await sql<{ id: string }[]>`
      SELECT id FROM patient_invites
      WHERE lower(email) = lower(${body.email})
        AND clinician_id = ${clinicianId}::UUID
        AND status = 'pending'
      LIMIT 1
    `;
    if (existingInvite) {
      return reply.status(409).send({
        success: false,
        error: { code: 'INVITE_PENDING', message: 'A pending invite already exists for this email' },
      });
    }

    // Insert invite — token is generated by DB default
    const [invite] = await sql<{
      id: string; token: string; email: string; expires_at: Date; status: string;
    }[]>`
      INSERT INTO patient_invites (clinician_id, org_id, email, personal_message)
      VALUES (
        ${clinicianId}::UUID,
        ${orgId}::UUID,
        ${body.email},
        ${body.personal_message ?? null}
      )
      RETURNING id, token, email, expires_at, status
    `;

    if (!invite) {
      return reply.status(500).send({
        success: false,
        error: { code: 'INTERNAL_ERROR', message: 'Failed to create invite' },
      });
    }

    const clinicianName = `${clinicianRow.first_name} ${clinicianRow.last_name}`;

    try {
      await sendInviteEmail({
        to: invite.email,
        token: invite.token,
        clinicianName,
        orgName: clinicianRow.org_name,
        expiresAt: new Date(invite.expires_at),
        ...(body.personal_message !== undefined && { personalMessage: body.personal_message }),
      });
    } catch (err) {
      // Log but don't fail the request — invite row is committed, email is best-effort
      fastify.log.error({ err }, '[invites] sendInviteEmail failed after insert');
    }

    await auditLog({
      actor: request.user,
      action: 'create',
      resourceType: 'patient_invite',
      resourceId: invite.id,
      ipAddress: request.ip,
      userAgent: request.headers['user-agent'],
      newValues: { email: invite.email },
    });

    return reply.status(201).send({
      success: true,
      data: {
        id: invite.id,
        email: invite.email,
        status: invite.status,
        expires_at: invite.expires_at,
      },
    });
  });

  // ---------------------------------------------------------------------------
  // GET /invites — list clinician's own invites
  // ---------------------------------------------------------------------------
  fastify.get('/', clinicianOnly, async (request, reply) => {
    const querySchema = z.object({
      status: z.enum(['pending', 'accepted', 'expired', 'cancelled']).optional(),
    });
    const { status } = querySchema.parse(request.query);

    const rows = await sql<{
      id: string; email: string; status: string; personal_message: string | null;
      expires_at: Date; accepted_at: Date | null; resend_count: number;
      created_at: Date; patient_id: string | null;
    }[]>`
      SELECT id, email, status, personal_message, expires_at, accepted_at,
             resend_count, created_at, patient_id
      FROM patient_invites
      WHERE clinician_id = ${request.user.sub}::UUID
        ${status ? sql`AND status = ${status}` : sql``}
      ORDER BY created_at DESC
    `;

    return reply.send({ success: true, data: rows });
  });

  // ---------------------------------------------------------------------------
  // GET /invites/validate/:token — PUBLIC (no auth)
  // Returns clinician name and org name so the registration form can pre-fill.
  // ---------------------------------------------------------------------------
  fastify.get('/validate/:token', async (request, reply) => {
    const { token } = z.object({ token: z.string().min(1) }).parse(request.params);

    const [invite] = await sql<{
      id: string;
      email: string;
      expires_at: Date;
      status: string;
      personal_message: string | null;
      clinician_first_name: string;
      clinician_last_name: string;
      org_name: string;
    }[]>`
      SELECT
        pi.id, pi.email, pi.expires_at, pi.status, pi.personal_message,
        c.first_name AS clinician_first_name,
        c.last_name  AS clinician_last_name,
        o.name       AS org_name
      FROM patient_invites pi
      JOIN clinicians c ON c.id = pi.clinician_id
      JOIN organisations o ON o.id = pi.org_id
      WHERE pi.token = ${token}
      LIMIT 1
    `;

    if (!invite) {
      return reply.status(404).send({
        success: false,
        error: { code: 'INVITE_NOT_FOUND', message: 'Invite not found' },
      });
    }

    if (invite.status === 'accepted') {
      return reply.status(409).send({
        success: false,
        error: { code: 'INVITE_USED', message: 'This invite has already been used' },
      });
    }

    if (invite.status === 'cancelled') {
      return reply.status(410).send({
        success: false,
        error: { code: 'INVITE_CANCELLED', message: 'This invite has been cancelled' },
      });
    }

    if (invite.status === 'expired' || new Date(invite.expires_at) < new Date()) {
      return reply.status(410).send({
        success: false,
        error: { code: 'INVITE_EXPIRED', message: 'This invite has expired' },
      });
    }

    return reply.send({
      success: true,
      data: {
        email: invite.email,
        clinician_name: `${invite.clinician_first_name} ${invite.clinician_last_name}`,
        org_name: invite.org_name,
        expires_at: invite.expires_at,
        personal_message: invite.personal_message,
      },
    });
  });

  // ---------------------------------------------------------------------------
  // POST /invites/:id/resend — resend email (max 3 times)
  // ---------------------------------------------------------------------------
  fastify.post('/:id/resend', clinicianOnly, async (request, reply) => {
    const { id } = z.object({ id: UuidSchema }).parse(request.params);
    const clinicianId = request.user.sub;

    const [invite] = await sql<{
      id: string; token: string; email: string; expires_at: Date;
      status: string; resend_count: number; personal_message: string | null;
      clinician_first_name: string; clinician_last_name: string; org_name: string;
    }[]>`
      SELECT
        pi.id, pi.token, pi.email, pi.expires_at, pi.status, pi.resend_count, pi.personal_message,
        c.first_name AS clinician_first_name,
        c.last_name  AS clinician_last_name,
        o.name       AS org_name
      FROM patient_invites pi
      JOIN clinicians c ON c.id = pi.clinician_id
      JOIN organisations o ON o.id = pi.org_id
      WHERE pi.id = ${id}::UUID
        AND pi.clinician_id = ${clinicianId}::UUID
      LIMIT 1
    `;

    if (!invite) {
      return reply.status(404).send({
        success: false,
        error: { code: 'NOT_FOUND', message: 'Invite not found' },
      });
    }

    if (invite.status !== 'pending') {
      return reply.status(400).send({
        success: false,
        error: { code: 'INVITE_NOT_PENDING', message: `Cannot resend — invite status is '${invite.status}'` },
      });
    }

    if (invite.resend_count >= MAX_RESENDS) {
      return reply.status(429).send({
        success: false,
        error: { code: 'RESEND_LIMIT_REACHED', message: `Maximum of ${MAX_RESENDS} resends allowed` },
      });
    }

    await sql`
      UPDATE patient_invites
      SET resend_count = resend_count + 1,
          resent_at    = NOW()
      WHERE id = ${id}::UUID
    `;

    const clinicianName = `${invite.clinician_first_name} ${invite.clinician_last_name}`;

    try {
      await sendInviteEmail({
        to: invite.email,
        token: invite.token,
        clinicianName,
        orgName: invite.org_name,
        expiresAt: new Date(invite.expires_at),
        ...(invite.personal_message !== null && { personalMessage: invite.personal_message }),
      });
    } catch (err) {
      fastify.log.error({ err }, '[invites] sendInviteEmail failed on resend');
    }

    return reply.send({
      success: true,
      data: { message: 'Invite resent', resend_count: invite.resend_count + 1 },
    });
  });

  // ---------------------------------------------------------------------------
  // DELETE /invites/:id — cancel a pending invite
  // ---------------------------------------------------------------------------
  fastify.delete('/:id', clinicianOnly, async (request, reply) => {
    const { id } = z.object({ id: UuidSchema }).parse(request.params);
    const clinicianId = request.user.sub;

    const [invite] = await sql<{ id: string; status: string }[]>`
      SELECT id, status FROM patient_invites
      WHERE id = ${id}::UUID
        AND clinician_id = ${clinicianId}::UUID
      LIMIT 1
    `;

    if (!invite) {
      return reply.status(404).send({
        success: false,
        error: { code: 'NOT_FOUND', message: 'Invite not found' },
      });
    }

    if (invite.status !== 'pending') {
      return reply.status(400).send({
        success: false,
        error: { code: 'INVITE_NOT_PENDING', message: `Cannot cancel — invite status is '${invite.status}'` },
      });
    }

    await sql`
      UPDATE patient_invites
      SET status = 'cancelled'
      WHERE id = ${id}::UUID
    `;

    await auditLog({
      actor: request.user,
      action: 'delete',
      resourceType: 'patient_invite',
      resourceId: id,
      ipAddress: request.ip,
      userAgent: request.headers['user-agent'],
    });

    return reply.send({ success: true, data: { message: 'Invite cancelled' } });
  });
}
